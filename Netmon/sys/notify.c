

#include "notify.h"
#include "ctl.h" // for globQueue
#pragma warning(disable:4204)

// {2890C75A-3426-4C89-B351-A0F3C571902A}
#define WPP_CONTROL_GUIDS \
	WPP_DEFINE_CONTROL_GUID(MsnMntrNotify,(2890C75A,3426,4C89,B351,A0F3C571902A),  \
		WPP_DEFINE_BIT(TRACE_CLIENT_SERVER)                 \
		WPP_DEFINE_BIT(TRACE_PEER_TO_PEER)                  \
		WPP_DEFINE_BIT(TRACE_UNKNOWN)                       \
		WPP_DEFINE_BIT(TRACE_ALL_TRAFFIC) )

#include "notify.tmh" //  This file will be auto generated


#define TAG_NAME_NOTIFY 'oNnM'

NTSTATUS
MonitorNfInitialize(
	_In_ DEVICE_OBJECT* deviceObject)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	UNREFERENCED_PARAMETER(deviceObject);

	return STATUS_SUCCESS;
}

NTSTATUS
MonitorNfUninitialize(void)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	return STATUS_SUCCESS;
}

__forceinline
void*
MonitorNfpFindCharacters(
	_In_reads_bytes_(streamLength) const char* stream,
	_In_ size_t streamLength,
	_In_reads_bytes_(subStreamLength) const char* subStream,
	_In_ size_t subStreamLength,
	_Out_ size_t* bytesLeft)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	size_t currentOffset = 0;
	void* subStreamPtr = NULL;

	*bytesLeft = streamLength;

	if (subStreamLength > streamLength)
	{
		return NULL;
	}

	while (currentOffset + subStreamLength <= streamLength)
	{
		// find string "\r\n\r\n in stream"
		if (0 == memcmp((void*)(stream + currentOffset), subStream, subStreamLength))
		{
			subStreamPtr = (void*)(char*)(stream + currentOffset);
			*bytesLeft = streamLength;
			*bytesLeft -= currentOffset;
			*bytesLeft -= subStreamLength;
			break;
		}
		currentOffset += subStreamLength;
	}

	// Get the contain starting at "\r\n\r\n"
	return subStreamPtr;
}

NTSTATUS
MonitorNfParseMessageInbound(
	_In_reads_bytes_(streamLength) BYTE* stream,
	_In_ size_t streamLength,
	_In_ USHORT localPort,
	_In_ USHORT remotePort)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	UNREFERENCED_PARAMETER(stream);
	UNREFERENCED_PARAMETER(streamLength);
	UNREFERENCED_PARAMETER(localPort);
	UNREFERENCED_PARAMETER(remotePort);

	DoTraceMessage(TRACE_CLIENT_SERVER,
				   "%Id bytes received. Local Port: %d Remote Port: %d.",
				   streamLength,
				   localPort,
				   remotePort);
	return STATUS_SUCCESS;
}

NTSTATUS
MonitorNfParseMessageInboundHttpHeader(
	_In_reads_bytes_(streamLength) BYTE* stream,
	_In_ size_t streamLength,
	_In_ USHORT localPort,
	_In_ USHORT remotePort)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	BYTE* msgStart = NULL;
	size_t bytesLeft;
	NTSTATUS status = STATUS_INVALID_PARAMETER;

	// Walk past the HTTP header.
	msgStart = (BYTE*)MonitorNfpFindCharacters((char*)stream,
											   streamLength,
											   "\r\n\r\n",
											   (ULONG)strlen("\r\n\r\n"),
											   &bytesLeft);
	if (msgStart && (bytesLeft > 0))
	{
		//DoTraceMessage(TRACE_CLIENT_SERVER, "r3: notify.c: Current IRQL at InboundHTTP: %d", KeGetCurrentIrql());

		size_t msgLength;

		msgStart += 4; // step past \r\n\r\n.

		msgLength = streamLength - (ULONG)(ULONG_PTR)(msgStart - stream);

		// Do the final inbound message processing.
		status = MonitorNfParseMessageInbound(msgStart,
											  msgLength,
											  localPort,
											  remotePort);
	}

	return status;
}

NTSTATUS
MonitorNfParseMessageOutbound(
	_In_reads_bytes_(streamLength) BYTE* stream,
	_In_ size_t streamLength,
	_In_ USHORT localPort,
	_In_ USHORT remotePort)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	UNREFERENCED_PARAMETER(stream);
	UNREFERENCED_PARAMETER(streamLength);
	UNREFERENCED_PARAMETER(localPort);
	UNREFERENCED_PARAMETER(remotePort);


	DoTraceMessage(TRACE_CLIENT_SERVER,
				   "%Id bytes sent. Local Port: %d Remote Port: %d.",
				   streamLength,
				   localPort,
				   remotePort);
	return STATUS_SUCCESS;
}

NTSTATUS
MonitorNfParseMessageOutboundHttpHeader(
	_In_reads_bytes_(streamLength) BYTE* stream,
	_In_ size_t streamLength,
	_In_ USHORT localPort,
	_In_ USHORT remotePort)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	BYTE* msgStart = NULL;
	size_t bytesLeft;
	NTSTATUS status = STATUS_SUCCESS;

	// Walk past the HTTP header.
	msgStart = (BYTE*)MonitorNfpFindCharacters((char*)stream,
											   streamLength,
											   "\r\n\r\n",
											   (ULONG)strlen("\r\n\r\n"),
											   &bytesLeft);
	if (msgStart && (bytesLeft > 0))
	{
		//DoTraceMessage(TRACE_CLIENT_SERVER, "r3: notify.c: Current IRQL at OutboundHTTP: %d", KeGetCurrentIrql());

		size_t msgLength;
		msgStart += 4; // step past \r\n\r\n.

		msgLength = streamLength - (ULONG)(ULONG_PTR)(msgStart - stream);
		status = MonitorNfParseMessageOutbound(msgStart,
											   msgLength,
											   localPort,
											   remotePort);
	}

	return status;
}

NTSTATUS
MonitorNfParseStreamAndTraceMessage(
	_In_reads_bytes_(streamLength) BYTE* stream,
	_In_ size_t streamLength,
	_In_ BOOLEAN inbound,
	_In_ USHORT localPort,
	_In_ USHORT remotePort)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	NTSTATUS status;

	UNREFERENCED_PARAMETER(remotePort);
	UNREFERENCED_PARAMETER(localPort);

	// Assign stream data to unsigned char array
	unsigned char* ucStream = stream;


	// Traffic is inbound or outbound?
	if (!inbound)
		DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: Request(%d):", streamLength);
	else
		DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: Response(%d):", streamLength);


	// Determine protocols
	switch (remotePort)
	{
		// FTP data 
	case 20:
	{
		DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: FTP data: %s", (const char*)ucStream);
		break;
	}

	// FTP commands
	case 21:
	{
		DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: FTP command: %s", (const char*)ucStream);
		break;
	}

	// SMTP
	case 25:
	{
		DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: SMTP: %s", (const char*)ucStream);
		break;
	}

	// HTTP
	case 80:
	{
		// Print GET and POST only
		char* getData = strstr((const char*)ucStream, "GET");
		char* postData = strstr((const char*)ucStream, "POST");
		char* httpData = strstr((const char*)ucStream, "HTTP");

		if (!inbound)
		{
			if ((getData != NULL))
				DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: HTTP: %s", (const char*)getData);
			if ((postData != NULL))
				DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: HTTP: %s", (const char*)postData);
		}
		else
		{
			if ((httpData != NULL))
				DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: HTTP: %s", (const char*)httpData);
		}

		break;
	}
	}

	if(remotePort >= 6660 && remotePort <= 7000)
		DoTraceMessage(TRACE_PEER_TO_PEER, "m3liss4: IRC: %s", (const char*)ucStream);


	status = STATUS_SUCCESS;

	return status;
}


NTSTATUS MonitorNfNotifyMessage(
	_In_ const FWPS_STREAM_DATA* streamBuffer,
	_In_ BOOLEAN inbound,
	_In_ USHORT localPort,
	_In_ USHORT remotePort
)
{
	DoTraceMessage(TRACE_CLIENT_SERVER, " %!FILE!: ----> %!FUNC!");

	NTSTATUS status = STATUS_SUCCESS;
	BYTE* stream = NULL;
	SIZE_T streamLength = streamBuffer->dataLength;
	SIZE_T bytesCopied = 0;

	if (streamLength == 0)
		return status;

	stream = ExAllocatePoolWithTag(NonPagedPool,
								   streamLength + 1,
								   TAG_NAME_NOTIFY);
	if (!stream)
		return STATUS_INSUFFICIENT_RESOURCES;

	RtlZeroMemory(stream, streamLength + 1);

	//DoTraceMessage(TRACE_CLIENT_SERVER, "r3: Before FwpsCopyStreamDataToBuffer. IRQL = %d", KeGetCurrentIrql());


	FwpsCopyStreamDataToBuffer(
		streamBuffer,
		stream,
		streamLength,
		&bytesCopied);


	NT_ASSERT(bytesCopied == streamLength);

	status = MonitorNfParseStreamAndTraceMessage(stream, streamLength, inbound, localPort, remotePort);

	ExFreePoolWithTag(stream, TAG_NAME_NOTIFY);

	return status;
}

