/*++

Copyright (c) Microsoft Corporation. All rights reserved

Abstract:

	Monitor Sample driver initialization routines

Environment:

	Kernel mode

--*/

#include <ndis.h>
#include <ntddk.h>
#include <wdf.h>
#include <Ntstrsafe.h>

#include <fwpmk.h>

#pragma warning(push)
#pragma warning(disable:4201)       // unnamed struct/union

#include <fwpsk.h>

#pragma warning(pop)

#include "ioctl.h"

#include "msnmntr.h"
#include "ctl.h"

#include "notify.h"
#include "ioctl.h"
#include <mntrguid.h>

//
// Software Tracing Definitions 
// {EB46335D-C74D-403C-A7ED-173C2535BDB8}
#define WPP_CONTROL_GUIDS \
	WPP_DEFINE_CONTROL_GUID(MsnMntrInit,(EB46335D,C74D,403C,A7ED,173C2535BDB8),  \
		WPP_DEFINE_BIT(TRACE_INIT)               \
		WPP_DEFINE_BIT(TRACE_SHUTDOWN) )

#include "init.tmh"




DEVICE_OBJECT* gWdmDevice;
HANDLE engineHandle = NULL; // handle for adding filter 

// ===========================================================================
//
// LOCAL PROTOTYPES
//
// ===========================================================================

DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD MonitorEvtDriverUnload;

void
SetCreateProcessNotifyRoutineEx(
	_In_ HANDLE ParentId,
	_In_ HANDLE ProcessId,
	_Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo
);

/*int GetProcNameOnly(
	PUNICODE_STRING usStringToGet,
	PUNICODE_STRING usStringToCmp
);*/

/*DWORD MonitorAddFilterChildProcess(
	PCWSTR AppPath,
	UINT32 appLength
);*/

/*typedef PCHAR(*GET_PROCESS_IMAGE_NAME) (PEPROCESS Process);
GET_PROCESS_IMAGE_NAME gGetProcessImageFileName;

extern   NTSTATUS PsLookupProcessByProcessId(
	HANDLE ProcessId,
	PEPROCESS *Process
);

extern UCHAR *PsGetProcessImageFileName(IN PEPROCESS Process);*/

// We're using what looks like a EVT_WDF_DRIVER_DEVICE_ADD callback, to keep
// this looking like a normal KMDF driver.  However, since this is a non-pnp
// driver, it will not be used as a callback; we will call it ourselves at the
// end of DriverEntry.  So, do not declare it as a callback.
// The NONPNP sample demonstrates this as well.
NTSTATUS
MonitorEvtDeviceAdd(
   _In_ PWDFDEVICE_INIT pInit
   );

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
DriverEntry(
	_In_ DRIVER_OBJECT* driverObject,
	_In_ UNICODE_STRING* registryPath
)
/*++

Routine Description:

	Main driver entry point. Called at driver load time

Arguments:

	driverObject            Our driver
	registryPath            A reg key where we can keep parameters

Return Value:

	status of our initialization. A status != STATUS_SUCCESS aborts the
	driver load and we don't get called again.

	Each component is responsible for logging any error that causes the
	driver load to fail.

--*/
{
	DoTraceMessage(TRACE_INIT, " %!FILE!: ----> %!FUNC!");

	// We have not received the app path
	bGotPath = FALSE;

	NTSTATUS status;
	WDF_DRIVER_CONFIG config;
	WDFDRIVER driver;
	PWDFDEVICE_INIT pInit = NULL;

	// Request NX Non-Paged Pool when available
	ExInitializeDriverRuntime(DrvRtPoolNxOptIn); //???

	//
	// This macro is required to initialize software tracing on XP and beyond
	// For XP and beyond use the DriverObject as the first argument.
	// 

	WPP_INIT_TRACING(driverObject, registryPath);

	WDF_DRIVER_CONFIG_INIT(&config, WDF_NO_EVENT_CALLBACK);
	config.DriverInitFlags |= WdfDriverInitNonPnpDriver; //???
	config.EvtDriverUnload = MonitorEvtDriverUnload; // unload callback function

	// Create driver object
	status = WdfDriverCreate(
		driverObject,
		registryPath,
		WDF_NO_OBJECT_ATTRIBUTES,
		&config,
		&driver
	);

	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	//
	// If you want your driver to create a control device object, 
	// the driver must call WdfControlDeviceInitAllocate to obtain a WDFDEVICE_INIT structure 
	// that it can pass to WdfDeviceCreate
	//
	pInit = WdfControlDeviceInitAllocate(driver, &SDDL_DEVOBJ_SYS_ALL_ADM_ALL);

	if (!pInit)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto cleanup;
	}

	status = MonitorEvtDeviceAdd(pInit);

cleanup:
	if (!NT_SUCCESS(status))
	{
		DoTraceMessage(TRACE_INIT, "MonitorSample Initialization Failed.");

		WPP_CLEANUP(driverObject);
	}

	// Set up notify function to add filter as soon as a new process is spawned
	status = PsSetCreateProcessNotifyRoutineEx(
		SetCreateProcessNotifyRoutineEx,
		FALSE);

	DoTraceMessage(TRACE_INIT, " %!FILE!: %!FUNC!: PsSetCreateProcessNotifyRoutineEx: 0x%x", status);

	if (!NT_SUCCESS(status))
		DoTraceMessage(TRACE_INIT, " %!FILE!: %!FUNC!: error at PsSetCreateProcessNotifyRoutineEx: 0x%x", status);

	return status;
}

NTSTATUS
MonitorEvtDeviceAdd(
	_In_ PWDFDEVICE_INIT pInit
)
/*
Description:
	- Create device object
	- Initializes the request queue for our driver
	- Initializes our flow tracking

*/
{
	DoTraceMessage(TRACE_INIT, " %!FILE!: ----> %!FUNC!");

	NTSTATUS status;
	WDFDEVICE device;
	DECLARE_CONST_UNICODE_STRING(ntDeviceName, MONITOR_DEVICE_NAME);
	DECLARE_CONST_UNICODE_STRING(symbolicName, MONITOR_SYMBOLIC_NAME);


	WdfDeviceInitSetDeviceType(pInit, FILE_DEVICE_NETWORK);
	WdfDeviceInitSetCharacteristics(pInit, FILE_DEVICE_SECURE_OPEN, FALSE);
	status = WdfDeviceInitAssignName(pInit, &ntDeviceName); // assigns a device name to a device's device object
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	/*WDF_IO_TYPE_CONFIG ioConfig;
	WDF_IO_TYPE_CONFIG_INIT(&ioConfig);
	ioConfig.ReadWriteIoType = WdfDeviceIoDirect;
	WdfDeviceInitSetIoTypeEx(pInit, &ioConfig);*/
	// Create device object
	status = WdfDeviceCreate(&pInit, WDF_NO_OBJECT_ATTRIBUTES, &device);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = WdfDeviceCreateSymbolicLink(device, &symbolicName); // The symbolic link to a specified device.
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = MonitorCtlDriverInit(&device); // Initializes the request queue for our driver
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	// returns the Windows Driver Model (WDM) device object that is associated with a specified framework device object
	gWdmDevice = WdfDeviceWdmGetDeviceObject(device);
	status = MonitorCoInitialize(gWdmDevice); // Initializes our flow tracking
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = MonitorNfInitialize(gWdmDevice); // does nothing
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	// The system will not send I/O requests or Windows Management Instrumentation (WMI) requests to a control device object 
	WdfControlFinishInitializing(device);

cleanup:
	// If WdfDeviceCreate was successful, it will set pInit to NULL.
	if (pInit)
	{
		WdfDeviceInitFree(pInit);
	}

	return status;
}

void
MonitorEvtDriverUnload(
	_In_ WDFDRIVER Driver
)
/*++

Routine Description:

	Called to indicate that we are being unloaded and to cause an orderly
	shutdown

Arguments:

	driverObject            Our driver

Return Value:

	None

--*/
{

	DoTraceMessage(TRACE_INIT, " %!FILE!: ----> %!FUNC!");

	NTSTATUS status;
	DRIVER_OBJECT* driverObject;


	// Free ucChildProcList
	for (int i = 0; i < iCount; i++)
	{
		if (structChildProcList[i].usProcPath.Buffer != NULL)
			ExFreePoolWithTag(structChildProcList[i].usProcPath.Buffer, '13m');
	}

	// Free usAppPath. It has been freed somewhere, we must find it out
	if (usAppPath != NULL)
		ExFreePoolWithTag(usAppPath, '23m');


	status = PsSetCreateProcessNotifyRoutineEx(
		SetCreateProcessNotifyRoutineEx,
		TRUE);
	if (!NT_SUCCESS(status))
		DbgPrint("m3liss4: Error at line 294 PsSetCreateProcessNotifyRoutineEx: 0x%x", status);

	// Close the engine handle
	/*if (engineHandle)
	{
		result = FwpmEngineClose(engineHandle);
		engineHandle = NULL;
	}*/

	DoTraceMessage(TRACE_INIT, "r3: init.c: MonitorEvtDriverUnload");

	MonitorCoUninitialize();
	MonitorNfUninitialize();

	DoTraceMessage(TRACE_SHUTDOWN, "MonitorSample Driver Shutting Down");

	driverObject = WdfDriverWdmGetDriverObject(Driver);
	WPP_CLEANUP(driverObject);

}


typedef NTSTATUS(*QUERY_INFO_PROCESS) (
	__in HANDLE ProcessHandle,
	__in PROCESSINFOCLASS ProcessInformationClass,
	__out_bcount(ProcessInformationLength) PVOID ProcessInformation,
	__in ULONG ProcessInformationLength,
	__out_opt PULONG ReturnLength
	);

// Undocumented API
QUERY_INFO_PROCESS ZwQueryInformationProcess;

void
SetCreateProcessNotifyRoutineEx(
	_In_ HANDLE ParentId,
	_In_ HANDLE ProcessId,
	_Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo
)
{
	DoTraceMessage(TRACE_INIT, " %!FILE!: ----> %!FUNC!");

	PAGED_CODE(); // this eliminates the possibility of the IDLE Thread/Process

	NTSTATUS status;
	HANDLE hParentProcHandle = NULL;
	OBJECT_ATTRIBUTES objAtt;
	CLIENT_ID cid;
	ULONG returnedLength;
	ULONG bufferLength;
	PVOID buffer;
	PUNICODE_STRING imageName; // == UNICODE_STRING *imageName
	UNICODE_STRING usTrimmedPath;
	SIZE_T stFinalPathLength;

	// We just monitor 10 processes
	if (iCount >= 10)
	{
		DbgPrint("m3liss4: Sorry! The current version of 10Box supports only 10 child processes.\n");
		return;
	}

	// We start monitor all processes after adding filter only
	if (bGotPath == FALSE)
	{
		return;
	}

	if (CreateInfo != NULL)
	{
		//
		// Convert PID to process handle
		//
		InitializeObjectAttributes(
			&objAtt,
			NULL,
			0,
			NULL,
			NULL);

		cid.UniqueProcess = CreateInfo->CreatingThreadId.UniqueProcess;
		cid.UniqueThread = NULL;

		status = ZwOpenProcess(
			&hParentProcHandle,
			PROCESS_ALL_ACCESS,
			&objAtt,
			&cid);

		if (!NT_SUCCESS(status))
		{
			DbgPrint(
				"m3liss4: Error at ZwOpenProcess: 0x%x",
				status);
		}
	}


	if (hParentProcHandle != NULL)
	{
		// Convert process handle to process name
		if (NULL == ZwQueryInformationProcess)
		{

			UNICODE_STRING routineName;

			RtlInitUnicodeString(&routineName, L"ZwQueryInformationProcess");

			ZwQueryInformationProcess =
				(QUERY_INFO_PROCESS)MmGetSystemRoutineAddress(&routineName);

			if (NULL == ZwQueryInformationProcess)
			{
				DbgPrint("Cannot resolve ZwQueryInformationProcess\n");
			}
		}
		//
		// Step one - get the size we need
		//
		status = ZwQueryInformationProcess(hParentProcHandle,
										   ProcessImageFileName,
										   NULL, // buffer
										   0, // buffer size
										   &returnedLength);

		if (STATUS_INFO_LENGTH_MISMATCH != status)
		{
			DbgPrint(
				"m3liss4: Error at line 402 ZwQueryInformationProcess: 0x%x",
				status);
		}

		//
		// Is the passed-in buffer going to be big enough for us?  
		// This function returns a single contguous buffer model...
		//
		bufferLength = returnedLength - sizeof(UNICODE_STRING);

		//if (ProcessImageName->MaximumLength < bufferLength) {

			//ProcessImageName->Length = (USHORT)bufferLength;

			//return STATUS_BUFFER_OVERFLOW;

		//}

		//
		// If we get here, the buffer IS going to be big enough for us, so 
		// let's allocate some storage.
		//
		buffer = ExAllocatePoolWithTag(PagedPool, returnedLength + 2, 'ipgD');

		if (buffer == NULL)
			return;

		RtlZeroMemory(buffer, returnedLength + 2);

		if (NULL == buffer) {

			DbgPrint("m3liss4: Error at line 433 ExAllocatePoolWithTag");
		}

		//
		// Now lets go get the data
		//
		status = ZwQueryInformationProcess(hParentProcHandle,
										   ProcessImageFileName,
										   buffer,
										   returnedLength,
										   &returnedLength);

		if (!NT_SUCCESS(status))
		{
			DbgPrint("m3liss4: ZwQueryInformationProcess failed: 0x%x\n", status);
			goto cleanup;
		}

		// Ah, we got what we needed
		imageName = (PUNICODE_STRING)buffer;

		if (NULL == imageName)
		{
			DbgPrint("m3liss4: imageName is NULL.\n");
			goto cleanup;
		}

		DbgPrint(
			"m3liss4: UniqueProcess: %lu. ChildProcessPath: %wZ. ChildLength: %d\n",
			CreateInfo->CreatingThreadId.UniqueProcess,
			CreateInfo->ImageFileName,
			CreateInfo->ImageFileName->Length);

		if (bGotPath != TRUE)
		{
			DbgPrint("m3liss4: bGotPath != TRUE.\n");
			goto cleanup;
		}
		// NOTE: must use UNICODE_STRING instead of PUNICODE_STRING
		// because the last one requires initialization, but we have no idea
		// about the string we're going to store so initialization is impossible
		UNICODE_STRING appPath;



		// Assign target's path to UNICODE_STRING
		status = RtlUnicodeStringInit(&appPath, usAppPath);


		if (!NT_SUCCESS(status))
		{
			DbgPrint("m3liss4: RtlUnicodeStringInit failed: 0x%x\n", status);
			goto cleanup;
		}

		// If the parent process path of the new child process is equal to
		// the process we are monitoring
		if (RtlEqualUnicodeString(imageName, &appPath, TRUE) == TRUE)
		{
			goto newTarget;
		}
		else
		{
			for (int i = 0; i < iCount; i++)
			{
				// must allocate pool to store, copying is just a pointer
				if (CreateInfo->ParentProcessId == structChildProcList[i].hPid)
				{
					goto newTarget;
				}
			}

			// Ignore the new process
			goto cleanup;
		}

	newTarget:
		// 1. Assign the new PID to global variable to monitor
		structChildProcList[iCount].hPid = ProcessId;

		// Convert "\??\C\xxx" path to "device\harddiskvolume2\xxx"

		// Pass the first 5 characters of string beginning with "\??\c:"
		// The new string begins with "\xxx"
		usTrimmedPath.Buffer = CreateInfo->ImageFileName->Buffer + 6;
		usTrimmedPath.Length = CreateInfo->ImageFileName->Length - 12;
		usTrimmedPath.MaximumLength = CreateInfo->ImageFileName->MaximumLength - 10; // preserve 2 bytes

		DbgPrint("m3liss4: usTrimmedPath: %wZ\n", &usTrimmedPath);

		// Prepare final string: usTrimmedString + "\device\harddiskvolume2" (46 bytes in length)
		stFinalPathLength = 46 + CreateInfo->ImageFileName->Length - 10;
		structChildProcList[iCount].usProcPath.Length = stFinalPathLength;
		structChildProcList[iCount].usProcPath.MaximumLength = 46 + CreateInfo->ImageFileName->MaximumLength - 10 + 2; // preserve 2 bytes
		structChildProcList[iCount].usProcPath.Buffer = ExAllocatePoolWithTag(NonPagedPool, stFinalPathLength, '13m');

		if (structChildProcList[iCount].usProcPath.Buffer == NULL)
		{
			DbgPrint("m3liss4: structChildProcList[%d].usProcPath.Buffer is NULL.\n", iCount);
			goto cleanup;
		}

		RtlZeroMemory(structChildProcList[iCount].usProcPath.Buffer, stFinalPathLength);

		// 2. Copy new process' path into structChildList
		// RtlUnicodeStringPrintf adjusts the length of the output string automatically
		status = RtlUnicodeStringPrintf(&structChildProcList[iCount].usProcPath, L"\\Device\\HarddiskVolume2%wZ", &usTrimmedPath);

		// Add 2 more bytes to compare with null-terminated string
		structChildProcList[iCount].usProcPath.Length += 2;

		if (status != STATUS_SUCCESS)
		{
			DbgPrint("m3liss4: RtlUnicodeStringPrintf failed: 0x%x\n", status);
			goto cleanup;
		}

		// Increase the number of member in structChildProcList
		iCount++;

		DbgPrint("m3liss4: structChildProcList now has %d member(s)\n", iCount);

		DbgPrint(
			"m3liss4: ParentProcessPath: %wZ. UniqueProcess: %lu. ChildProcessPath: %wZ\n",
			imageName,
			CreateInfo->CreatingThreadId.UniqueProcess,
			CreateInfo->ImageFileName);


	// free our buffer
	cleanup:
		if (buffer != NULL)
			ExFreePoolWithTag(buffer, 'ipgD');

	} // if (hParentProcHandle != NULL)
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add filter to monitor new process
//
/*DWORD MonitorAddFilterChildProcess(
	PCWSTR AppPath,
	UINT32 appLength
)
{
	DWORD result = 0;
	FWP_BYTE_BLOB *appId = NULL;
	FWPM_SESSION session;
	

	// Get app ID from app path
	//result = FwpmGetAppIdFromFileName0(AppPath, appId);
	

	if (result != 0)
	{
		DbgPrint("m3liss4: FwpmGetAppIdFromFileName failed: %d\n", result);
		return result;
	}

	// Open engine
	session.displayData.name = L"Child Process Add Filter";
	session.displayData.description = L"Add filter for new child process";
	// All the filter will be closed automatically
	// after the malware is terminated
	session.flags = FWPM_SESSION_FLAG_DYNAMIC;

	result = FwpmEngineOpen(
		NULL,
		RPC_C_AUTHN_WINNT,
		NULL,
		&session,
		&engineHandle);

	if (result != 0)
	{
		DbgPrint("m3liss4: FwpmEngineOpen failed: %d\n", result);
		return result;
	}

	// Start a transaction
	result = FwpmTransactionBegin(engineHandle, 0);

	if (result != 0)
	{
		DbgPrint("m3liss4: FwpmTransactionBegin failed: %d\n", result);
		return result;
	}

	// Add callout
	

	// Add sublayer
	FWPM_SUBLAYER fwpSubLayer;
	RtlZeroMemory(&fwpSubLayer, sizeof(FWPM_SUBLAYER));
	
	fwpSubLayer.subLayerKey = MONITOR_CHILD_PROCESS_SUBLAYER;
	fwpSubLayer.displayData.name = L"Child process sublayer";
	fwpSubLayer.displayData.description = L"Sublayer for child process";
	fwpSubLayer.flags = 0;
	fwpSubLayer.weight = 0;

	result = FwpmSubLayerAdd(engineHandle, &fwpSubLayer, NULL);
	
	if (result != 0)
	{
		DbgPrint("m3liss4: FwpmTransactionBegin failed: %d\n", result);
		return result;
	}

	// Add filter
	FWPM_FILTER fwpFilter;
	FWPM_FILTER_CONDITION filterConditions[1];
	RtlZeroMemory(&fwpFilter, sizeof(FWPM_FILTER));

	fwpFilter.layerKey = FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4;
	fwpFilter.displayData.name = L"Child Process Flow Established Filter";
	fwpFilter.displayData.description = L"Sets up flow for child process traffic";
	fwpFilter.action.type = FWP_ACTION_CALLOUT_INSPECTION;
	fwpFilter.action.calloutKey = CHILD_PROCESS_FLOW_ESTABLISHED_CALLOUT_V4;
	fwpFilter.filterCondition = filterConditions;
	fwpFilter.subLayerKey = fwpSubLayer.subLayerKey;
	fwpFilter.weight.type = FWP_EMPTY;
	fwpFilter.numFilterConditions = 1;

	// Add filter conditions
	RtlZeroMemory(filterConditions, sizeof(FWPM_FILTER_CONDITION));
	

	filterConditions[0].fieldKey = FWPM_CONDITION_IP_PROTOCOL;
	filterConditions[0].matchType = FWP_MATCH_EQUAL;
	filterConditions[0].conditionValue.type = FWP_UINT8;
	filterConditions[0].conditionValue.uint8 = IPPROTO_TCP;

	result = FwpmFilterAdd(
		engineHandle,
		&fwpFilter,
		NULL,
		NULL);

	if (result != 0)
	{
		DbgPrint("m3liss4: FwpmFilterAdd failed: %d\n", result);
		return result;
	}

	// Commit transaction
	result = FwpmTransactionCommit(engineHandle);

	if (result != 0)
	{
		DbgPrint("m3liss4: FwpmTransactionCommit failed: %d\n", result);
		return result;
	}

	// Free the appId
	// We use if here to avoid freeing invalid memory block
	if (appId)
		FwpmFreeMemory((void**)&appId);

	// The engine will be closed when the driver is unloaded
	// because closing the engine here will delete the filter we've added above

	return result;
}*/





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to create a new PUNICODE_STRING that point to the character
// after the second '\' character of the string 'Device\HardDiskVolume2\***' 
// to eliminate the first part of the given string
//
// Note that we do not create new string, we just create a new pointer
// to point to the portion we need of the given string. Therefore, if the
// given string is freed, our trimmed string is point to some weird values.
//
/*int GetProcNameOnly(
	PUNICODE_STRING usStringToGet,
	PUNICODE_STRING usTrimmedString
)
{
	// Make sure that we're in PASSIVE_LEVEL
	DbgPrint("---->GetProcNameOnly. IRQL = %d", KeGetCurrentIrql());

	WCHAR *p;
	PWCHAR pLast;
	
	if (usStringToGet->Buffer == NULL)
	{
		DbgPrint("m3liss4: usStringToGet->Buffer is NULL");
		return -1;
	}
	// Set pLast to point to the last character of the string
	// (not included null terminator if available)
	pLast = usStringToGet->Buffer + ((usStringToGet->Length) / sizeof(WCHAR));

	// Set the pointer of new string to the beginning of the input string
	p = usStringToGet->Buffer;

	if ((pLast != NULL) && (p != NULL))
	{
			while (p < pLast)
			{
				// we touch '2' in 'Device\Harddiskvolume2\*' string
				if (*p == '2')
				{
					// bypass '\'
					p = p + 2;
					// set position for new string. For example: if string is 'Device\HarddiskVolume2\Windows\firefox.exe' 
					// the new string will be 'Windows\firefox.exe'
					// If usStringToCmp was initialized as a NULL pointer (use Windbg to check) 
					// these below code will cause BSOD
					usTrimmedString->Length = (USHORT)((pLast - p) * sizeof(WCHAR));
					usTrimmedString->MaximumLength = usTrimmedString->Length + 2;
					usTrimmedString->Buffer = p;

					// we've got what we need, get out!
					// we don't need null terminator even if it is available
					return 0;
				}
				p++;
			}
			return -2;
	}
	else 
		return -1;
}*/


