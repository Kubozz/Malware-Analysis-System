/*++

Copyright (c) Microsoft Corporation. All rights reserved

Abstract:

	Monitor Sample driver IO control routines

Environment:

	Kernel mode

--*/

#include <ntddk.h>
#include <wdf.h>
#include <ntstrsafe.h>

#include <fwpmk.h>

#pragma warning(push)
#pragma warning(disable:4201)       // unnamed struct/union

#include <fwpsk.h>

#pragma warning(pop)


#include "ioctl.h"

#include "msnmntr.h"
#include "ctl.h"

#include "notify.h"

//
// Software Tracing Definitions 
// {81E3E109-4017-4C11-9D3B-E59FE3C3875F}
#define WPP_CONTROL_GUIDS \
	WPP_DEFINE_CONTROL_GUID(MsnMntrCtl,(81E3E109,4017,4C11,9D3B,E59FE3C3875F),  \
		WPP_DEFINE_BIT(TRACE_INIT)               \
		WPP_DEFINE_BIT(TRACE_DEVICE_CONTROL)     \
		WPP_DEFINE_BIT(TRACE_STATE) )

#include "ctl.tmh"

EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL MonitorEvtDeviceControl;




NTSTATUS
MonitorCtlDriverInit(
	_In_ WDFDEVICE* pDevice
)
/*++

Routine Description:

   Initializes the request queue for our driver.  This is how
   DeviceIoControl requests are sent to KMDF drivers.

Arguments:

   [in]  WDFDEVICE* pDevice - Our device.

--*/
{

	DoTraceMessage(TRACE_INIT, " %!FILE!: ----> %!FUNC!");

	NTSTATUS status;
	WDF_IO_QUEUE_CONFIG queueConfig;

	WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(
		&queueConfig,
		WdfIoQueueDispatchParallel
	);

	// https://msdn.microsoft.com/en-us/library/windows/hardware/ff541758(v=vs.85).aspx
	// the callback function MonitorEvtDeviceControl receives every I/O control request (IRP_MJ_DEVICE_CONTROL) from the queue
	queueConfig.EvtIoDeviceControl = MonitorEvtDeviceControl;

	// creates and configures an I/O queue for a specified device
	status = WdfIoQueueCreate(
		*pDevice,
		&queueConfig,
		WDF_NO_OBJECT_ATTRIBUTES,
		NULL
	);
	if (NT_SUCCESS(status))
		DoTraceMessage(TRACE_INIT, "r3: %!FUNC!: Queue created successfully with status: 0x%x", status);

	// Create a new queue to recieve stream data from driver

	WDF_IO_QUEUE_CONFIG queueConfigInvertedCall;

	WDF_IO_QUEUE_CONFIG_INIT(
		&queueConfigInvertedCall,
		WdfIoQueueDispatchManual
	);

	queueConfigInvertedCall.PowerManaged = WdfFalse;

	status = WdfIoQueueCreate(
		*pDevice,
		&queueConfigInvertedCall,
		WDF_NO_OBJECT_ATTRIBUTES,
		&globQueue
	);

	if (!NT_SUCCESS(status))
		DoTraceMessage(TRACE_INIT, "r3: %!FILE!: %!FUNC!: error at WdfIoQueueCreate for inverted call: 0x%x", status);

	return status;
}

VOID
MonitorEvtDeviceControl(
	_In_ WDFQUEUE Queue,
	_In_ WDFREQUEST Request,
	_In_ size_t OutputBufferLength,
	_In_ size_t InputBufferLength,
	_In_ ULONG IoControlCode
)
/*++

   Handles device IO control requests. This callback drives all communication
   between the usermode exe and this driver.

--*/
{

	DoTraceMessage(TRACE_INIT, " %!FILE!: ----> %!FUNC!");

	NTSTATUS status = STATUS_SUCCESS;
	PWCHAR inBuf = 0; // Zero out inBuf to make sure that the string is null-terminated
	size_t inBufLength;

	UNREFERENCED_PARAMETER(Queue);
	UNREFERENCED_PARAMETER(InputBufferLength);
	UNREFERENCED_PARAMETER(OutputBufferLength);

	switch (IoControlCode)
	{
	case MONITOR_IOCTL_GET_STREAM_DATA:
	{
		DbgPrint("m3liss4: Receive IOCTL from user-mode application. IRQL = %d", KeGetCurrentIrql());
		// check the length of the recieving buffer if it is enough to store all stream data
		//if (OutputBufferLength < 2000)
		//{
			//DoTraceMessage(TRACE_INIT, "r3: %!FILE!: %!FUNC!: OutputBufferLength: %d", OutputBufferLength);
			//break;
		//}

		status = WdfRequestForwardToIoQueue(
			Request,
			globQueue
		);

		if (!NT_SUCCESS(status))
		{
			DbgPrint("m3liss4: Error at WdfRequestForwardToIoQueue");
			//DoTraceMessage(TRACE_INIT, "r3: %!FILE!: %!FUNC!: error at WdfRequestForwardToIoQueue: 0x%x", status);
			break;
		}

		break;
	}

	case MONITOR_IOCTL_APP_PATH:
	{
		if (InputBufferLength == 0)
		{
			DbgPrint("InputBufferLength = NULL\n");
			break;
		}
		// Retrieve input buffer
		status = WdfRequestRetrieveInputBuffer(
			Request,
			0,
			&inBuf,
			&inBufLength);

		if (!NT_SUCCESS(status))
		{
			DbgPrint("m3liss4: WdfRequestRetrieveInputBuffer error: 0x%x\n", status);
			break;
		}

		if (inBuf == NULL)
		{
			DbgPrint("inBuf is NULL.\n");
			break;
		}

		DbgPrint("m3liss4: inbuf(%d): %S\n", inBufLength, inBuf);

		usAppPath = ExAllocatePoolWithTag(NonPagedPool, inBufLength, '23m');

		if (usAppPath == NULL)
		{
			DbgPrint("m3liss4: usAppPath is NULL.\n");
			break;
		}


		RtlZeroMemory(usAppPath, inBufLength);

		// Copy app path to a global variable for later use.
		status = RtlStringCbCopyW(usAppPath, inBufLength, inBuf);
		DbgPrint("RtlStringCbCopyW status: 0x%x\n", status);

		// notify SetCreateProcessNotifyRoutineEx that the path is ready to use.
		bGotPath = TRUE;






		// Assign to global variable

		WdfRequestComplete(Request, status);




		status = STATUS_SUCCESS;
		// receive and process usermode noti here
		break;
	}

	default:
	{
		status = STATUS_INVALID_PARAMETER;
	}
	}

	//WdfRequestComplete(Request, status);
}
