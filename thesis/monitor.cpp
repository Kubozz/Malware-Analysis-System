/*++

Copyright (c) Microsoft Corporation. All rights reserved

Abstract:

Stream monitor sample executable

Environment:

User mode

--*/

#include "windows.h"
#include "winioctl.h"
#include "strsafe.h"

#ifndef _CTYPE_DISABLE_MACROS
#define _CTYPE_DISABLE_MACROS
#endif

#include "fwpmu.h"

#include "winsock2.h"
#include "ws2def.h"

#include <conio.h>
#include <stdio.h>
#include <stdlib.h> // for system()
#include <errno.h> // for system() error check
#include <string.h> // for strerror()
#include <Subauth.h> // for UNICODE_STRING

#include "ioctl.h"

#define INITGUID
#include <guiddef.h>
#include "mntrguid.h"


#define MONITOR_FLOW_ESTABLISHED_CALLOUT_DESCRIPTION L"Monitor Sample - Flow Established Callout"
#define MONITOR_FLOW_ESTABLISHED_CALLOUT_NAME L"Flow Established Callout"

#define MONITOR_STREAM_CALLOUT_DESCRIPTION L"Monitor Sample - Stream Callout"
#define MONITOR_STREAM_CALLOUT_NAME L"Stream Callout"

#define CHILD_ALE_CALLOUT_DESCRIPTION L"Monitor child process - ALE Callout"
#define CHILD_ALE_CALLOUT_NAME L"ALE Callout"

typedef struct _PROCESS_NAME
{
	OVERLAPPED Overlapped;
	PUNICODE_STRING utProcName;
}PROCESS_NAME, *PPROCESS_NAME;

//DWORD
//WINAPI CompletionPortThread(LPVOID PortHandle);

HANDLE quitEvent;
PCWSTR globPath = 0;

DWORD
MonitorAppOpenMonitorDevice(
	_Out_ HANDLE* monitorDevice)
	/*++

	Routine Description:

	Opens the Monitor Sample monitorDevice

	Arguments:

	[out] HANDLE* monitorDevice

	Return Value:

	NO_ERROR, ERROR_INVALID_PARAMETER or a CreateFile specific result.

	--*/
{
	if (!monitorDevice)
	{
		return ERROR_INVALID_PARAMETER;
	}
	// To retrieve a handle to the device, 
	// you must call the CreateFile function with either the name of a device or the name of the driver associated with a device
	// https://msdn.microsoft.com/en-us/library/windows/desktop/aa363216(v=vs.85).aspx
	// https://msdn.microsoft.com/en-us/library/windows/hardware/ff544531(v=vs.85).aspx
	// MONITOR_DOS_NAME is defined by you
	*monitorDevice = CreateFileW(MONITOR_DOS_NAME,
								 GENERIC_READ | GENERIC_WRITE,
								 FILE_SHARE_READ | FILE_SHARE_WRITE,
								 NULL,
								 OPEN_EXISTING,
								 FILE_FLAG_OVERLAPPED,
								 NULL);

	if (*monitorDevice == INVALID_HANDLE_VALUE)
	{
		return GetLastError();
	}



	return NO_ERROR;
}


BOOL MonitorAppCloseMonitorDevice(
	_In_ HANDLE monitorDevice)
	/*++

	Routine Description:

	Closes the Monitor Sample monitorDevice

	Arguments:

	Return Value:

	None.

	--*/
{
	return CloseHandle(monitorDevice);
}

DWORD
MonitorAppAddCallouts()
/*++

Routine Description:

Adds the callouts during installation

Arguments:

[in]  PCWSTR AppPath - The path to the application to monitor.

Return Value:

NO_ERROR or a specific FWP result.

--*/
{
	FWPM_CALLOUT callout;
	DWORD result;
	FWPM_DISPLAY_DATA displayData;
	HANDLE engineHandle = NULL;
	FWPM_SESSION session;
	RtlZeroMemory(&session, sizeof(FWPM_SESSION));

	session.displayData.name = L"Monitor Sample Non-Dynamic Session";
	session.displayData.description = L"For Adding callouts";

	printf("Opening Filtering Engine\n");
	result = FwpmEngineOpen(
		NULL,
		RPC_C_AUTHN_WINNT,
		NULL,
		&session,
		&engineHandle
	);

	if (NO_ERROR != result)
	{
		goto cleanup;
	}

	printf("Starting Transaction for adding callouts\n");
	result = FwpmTransactionBegin(engineHandle, 0);
	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully started the Transaction\n");

	RtlZeroMemory(&callout, sizeof(FWPM_CALLOUT));
	displayData.description = MONITOR_FLOW_ESTABLISHED_CALLOUT_DESCRIPTION;
	displayData.name = MONITOR_FLOW_ESTABLISHED_CALLOUT_NAME;

	callout.calloutKey = MONITOR_SAMPLE_FLOW_ESTABLISHED_CALLOUT_V4;
	callout.displayData = displayData;
	// This filtering layer allows for notification of when a TCP connection has been established, or when non-TCP traffic has been authorized
	callout.applicableLayer = FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4;
	callout.flags = FWPM_CALLOUT_FLAG_PERSISTENT; // Make this a persistent callout.

	printf("Adding Persistent Flow Established callout through the Filtering Engine\n");

	// Add callout
	result = FwpmCalloutAdd(engineHandle, &callout, NULL, NULL);
	//
	printf("result (return from FwpmCalloutAdd) == %x\n", result);

	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully Added Persistent Flow Established callout.\n");

	RtlZeroMemory(&callout, sizeof(FWPM_CALLOUT));

	displayData.description = MONITOR_STREAM_CALLOUT_DESCRIPTION;
	displayData.name = MONITOR_STREAM_CALLOUT_DESCRIPTION;

	callout.calloutKey = MONITOR_SAMPLE_STREAM_CALLOUT_V4;
	callout.displayData = displayData;
	// This layer allows for inspecting network data on a per stream basis. At the stream layer, the network data is bidirectional
	callout.applicableLayer = FWPM_LAYER_STREAM_V4;
	callout.flags = FWPM_CALLOUT_FLAG_PERSISTENT; // Make this a persistent callout.

	printf("Adding Persistent Stream callout through the Filtering Engine\n");

	result = FwpmCalloutAdd(engineHandle, &callout, NULL, NULL);
	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully Added Persistent Stream callout.\n");



	// Add callout for child process
	// Reuse "callout" variable
	RtlZeroMemory(&callout, sizeof(FWPM_CALLOUT));

	// Assign parameters
	displayData.description = CHILD_ALE_CALLOUT_DESCRIPTION;
	displayData.name = CHILD_ALE_CALLOUT_NAME;
	callout.calloutKey = CHILD_PROCESS_FLOW_ESTABLISHED_CALLOUT_V4;
	callout.displayData = displayData;
	callout.applicableLayer = FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4;
	callout.flags = FWPM_CALLOUT_FLAG_PERSISTENT;

	printf("Adding Persistent callout for child process through the Filtering Engine\n");
	result = FwpmCalloutAdd(engineHandle, &callout, NULL, NULL);

	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully Added callout for child process.\n");

	printf("Committing Transaction\n");
	result = FwpmTransactionCommit(engineHandle);
	if (NO_ERROR == result)
	{
		printf("Successfully Committed Transaction.\n");
	}
	goto cleanup;

abort:
	printf("Aborting Transaction\n");
	result = FwpmTransactionAbort(engineHandle);
	if (NO_ERROR == result)
	{
		printf("Successfully Aborted Transaction.\n");
	}

cleanup:

	if (engineHandle)
	{
		FwpmEngineClose(engineHandle);
	}
	return result;
}

DWORD
MonitorAppRemoveCallouts()
/*++

Routine Description:

Sets the kernel callout ID's through the Monitor Sample device

Arguments:

[in] HANDLE monitorDevice - Monitor Sample device
[in] CALLOUTS* callouts - Callout structure with ID's set
[in] DWORD size - Size of the callout structure.

Return Value:

NO_ERROR or a specific DeviceIoControl result.

--*/
{
	DWORD result;
	HANDLE engineHandle = NULL;
	FWPM_SESSION session;

	RtlZeroMemory(&session, sizeof(FWPM_SESSION));

	session.displayData.name = L"Monitor Sample Non-Dynamic Session";
	session.displayData.description = L"For Adding callouts";

	printf("Opening Filtering Engine\n");
	result = FwpmEngineOpen(
		NULL,
		RPC_C_AUTHN_WINNT,
		NULL,
		&session,
		&engineHandle
	);

	if (NO_ERROR != result)
	{
		goto cleanup;
	}

	printf("Starting Transaction for Removing callouts\n");

	result = FwpmTransactionBegin(engineHandle, 0);
	if (NO_ERROR != result)
	{
		goto abort;
	}
	printf("Successfully started the Transaction\n");


	/*// Filters will be deleted first
	printf("Deleting Flow Established filter\n");
	result = FwpmFilterDeleteByKey(engineHandle, &MONITOR_FLOW_ESTABLISHED_FILTER_V4);

	if (NO_ERROR != result)
	{
		printf("FwpmFilterDeleteByKey failed: 0x%x\n", result);
		//goto abort;
	}

	printf("Deleting Stream Filter\n");
	result = FwpmFilterDeleteByKey(engineHandle, &MONITOR_STREAM_FILTER_V4);

	if (NO_ERROR != result)
	{
		printf("FwpmFilterDeleteByKey failed: 0x%x\n", result);
		//goto abort;
	}

	printf("Deleting sub-layer\n");
	result = FwpmSubLayerDeleteByKey(engineHandle, &MONITOR_SAMPLE_SUBLAYER);
	if (NO_ERROR != result)
	{
		printf("FwpmSubLayerDeleteByKey failed: 0x%x\n", result);
		//goto abort;
	}*/



	printf("Deleting Flow Established callout\n");
	result = FwpmCalloutDeleteByKey(engineHandle,
									&MONITOR_SAMPLE_FLOW_ESTABLISHED_CALLOUT_V4);
	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully Deleted Flow Established callout\n");

	printf("Deleting Stream callout\n");

	result = FwpmCalloutDeleteByKey(engineHandle,
									&MONITOR_SAMPLE_STREAM_CALLOUT_V4);
	if (NO_ERROR != result)
	{
		goto abort;
	}
	printf("Successfully Deleted Stream callout\n");


	printf("Deleting callout for child process\n");
	result = FwpmCalloutDeleteByKey(engineHandle, &CHILD_PROCESS_FLOW_ESTABLISHED_CALLOUT_V4);

	if (NO_ERROR != result)
	{
		goto abort;
	}
	printf("Successfully Deleted callout for child process\n");
	


	printf("Committing Transaction\n");
	result = FwpmTransactionCommit(engineHandle);
	if (NO_ERROR == result)
	{
		printf("Successfully Committed Transaction.\n");
	}
	goto cleanup;

abort:
	printf("Aborting Transaction\n");
	result = FwpmTransactionAbort(engineHandle);
	if (NO_ERROR == result)
	{
		printf("Successfully Aborted Transaction.\n");
	}

cleanup:

	if (engineHandle)
	{
		FwpmEngineClose(engineHandle);
	}

	return result;
}

// Struct for receiving process name
typedef struct _PROC_NAME
{
	OVERLAPPED Overlapped;
	PBYTE cProcName;
}OVL_PROCNAME, *POVL_PROCNAME;


/*DWORD
MonitorAppSendIoclt(
	_In_    HANDLE            monitorDevice
)
/*++

Routine Description:

Enables monitoring on new connections.

Arguments:

[in] HANDLE monitorDevice - Monitor Sample device
[in] MONITOR_SETTINGS* monitorSettings - Settings for the Monitor Sample driver.

Return Value:

NO_ERROR or a specific DeviceIoControl result.

--
{
	DWORD dwErr;
	DWORD bytesReturned, bytesReturned2;
	int status = 0;
	OVERLAPPED overlappedStruct; // remember to use this structure when using asynchronous IOCTL
	OVERLAPPED *pOverlappedStruct = NULL;
	OVERLAPPED overlappedStruct2;
	OVERLAPPED *pOverlappedStruct2 = NULL;
	OVERLAPPED OvlStructToWait = { 0 };
	OVERLAPPED *pOvlStructToWait = &OvlStructToWait; // check if the pointer is initialized correctly
	HANDLE hOvlEvent; // the event will be associated with OVERLAPPED
	wchar_t outBuf[200] = { 0 }; // Don't forget to zero all the members to avoid non-nullterminated string
	wchar_t outBuf2[200] = { 0 };
	DWORD byteCount = 0;
	ULONG_PTR compKey = 0;
	int errCode;
	errno_t err;
	wchar_t pcMonitor[222] = { 0 };
	wchar_t pcMonitor2[222] = { 0 };

	// Create an event to be signaled when receiving IOCTL back from driver
	hOvlEvent = CreateEvent(
		NULL,
		TRUE,
		FALSE,
		NULL);
	dwErr = GetLastError();

	if (hOvlEvent == NULL)
	{
		printf("Cannot create event with error: %d\n", dwErr);
		CloseHandle(hOvlEvent);
		return dwErr;
	}

	// Create event to signal the driver
	// to release the new sub-process

	HANDLE hWaitEvent = CreateEvent(
		NULL,
		TRUE,
		FALSE,
		"Global\\SharedEvent");

	dwErr = GetLastError();

	if (hWaitEvent == NULL)
	{
		printf("Cannot create event with error: %d\n", dwErr);
		CloseHandle(hWaitEvent);
		return dwErr;
	}

	// Initialize OVERLAPPED structure
	// NOTE: if you don't assign event for OVERLAPPED structure
	// the IOCTL request will be canceled (confirmation needed)
	overlappedStruct.hEvent = hOvlEvent;
	overlappedStruct.Offset = 0;
	overlappedStruct.OffsetHigh = 0;

	overlappedStruct2.hEvent = hOvlEvent;
	overlappedStruct2.Offset = 0;
	overlappedStruct2.OffsetHigh = 0;

	// Get a pointer to OVERLAPPED struct
	// Do so because declaring a OVERLAPPED*
	// will require us to initialize it
	pOverlappedStruct = &overlappedStruct;
	pOverlappedStruct2 = &overlappedStruct2;

	// Sends a control code directly to a specified device driver, 
	// causing the corresponding device to perform the corresponding operation.
	// Using overlapped IO
	// MONITOR_IOCTL_ENABLE_MONITOR is created by us
	printf("IOCTL is sent by DeviceIoControl. Begin to wait...\n");

	// Do not use UNICODE_STRING for outbuf
	// because it is rarely used in usermode
	status = DeviceIoControl(monitorDevice,
							 MONITOR_IOCTL_GET_STREAM_DATA,
							 NULL,
							 0,
							 &outBuf,
							 sizeof(outBuf),
							 &bytesReturned,
							 pOverlappedStruct);

	dwErr = GetLastError();

	// Asynchronous DeviceIoControl will return status 0
	// and error ERROR_IO_PENDING. If not, there is a bug
	if (0 == status)
	{
		if (ERROR_IO_PENDING == dwErr)
		{
			printf("IOCTL1 operation is pending\n");

			status = DeviceIoControl(monitorDevice,
									 MONITOR_IOCTL_GET_STREAM_DATA,
									 NULL,
									 0,
									 &outBuf2,
									 sizeof(outBuf2),
									 &bytesReturned2,
									 pOverlappedStruct2);

			dwErr = GetLastError();

			// Asynchronous DeviceIoControl will return status 0
			// and error ERROR_IO_PENDING. If not, there is a bug
			if (0 == status)
			{
				if (ERROR_IO_PENDING == dwErr)
				{
					// Create completion port
					HANDLE completionPortHandle;
					completionPortHandle = CreateIoCompletionPort(
						monitorDevice,
						NULL,
						0,
						0);

					dwErr = GetLastError();

					if (completionPortHandle == NULL)
					{
						printf("CreateCompletionPort failed: %d\n", dwErr);
						return dwErr;
					}

					// Start to wait for IOCTL


					// equal to while(TRUE)
					// Actually, we don't need a loop here
					// Because we just wait for 1 completed IO request only
					for (int i = 0; i <= 1; i++)
					{
						//overlappedStruct = NULL;
						//byteCount = 0;
						//compKey = 0;
						OvlStructToWait = { 0 };

						BOOL worked = GetQueuedCompletionStatus(
							completionPortHandle,
							&byteCount,
							&compKey,
							&pOvlStructToWait,
							INFINITE);

						dwErr = GetLastError();

						// Get successfully IO request
						if (worked == TRUE && outBuf[0] != 0)
						{
							// We've got the process name
							printf("WARNING!!! We've got the ProcName from the driver\n");
							printf(
								"overlapped: error code: %lu; #bytes transferred: %lu\n",
								pOvlStructToWait->Internal,
								pOvlStructToWait->InternalHigh);
							printf("sizeof(outBuf): %d\n", sizeof(outBuf));
							printf("Buffer (%d): %S\n", byteCount, outBuf);

							wchar_t *wcSysRoot = L"\SystemRoot";
							wchar_t *pwcDetectSysRoot = NULL;

							pwcDetectSysRoot = wcsstr(wcSysRoot, outBuf);

							if (pwcDetectSysRoot != NULL)
							{
								StringCchPrintfW(pcMonitor, _countof(pcMonitor), L"monitor2 monitor \"C:\Windows%ls\"", outBuf[11]);
							}
							else
								StringCchPrintfW(pcMonitor, _countof(pcMonitor), L"monitor2 monitor \"%ls\"", outBuf); // Concatinate to form a full command

							printf("Running msnmntr2...\n");
							// Change the string within system() to open a program




							status = _wsystem(pcMonitor);

							// Check if the system() is failed
							if (status == -1)
							{
								err = _get_errno(&errCode);
								printf("errno = %d\n", err);
							}

							// Notify the driver that we finished starting msnmntr2
							BOOL bEventStatus = SetEvent(hWaitEvent);
							if (bEventStatus == 0)
								printf("Error at SetEvent\n");

						}
						else
						{
							if (worked == TRUE && outBuf2[0] != 0)
							{
								// We've got the process name
								printf("WARNING!!! We've got the ProcName2 from the driver\n");
								printf(
									"overlapped2: error code: %lu; #bytes transferred2: %lu\n",
									pOvlStructToWait->Internal,
									pOvlStructToWait->InternalHigh);
								printf("sizeof(outBuf2): %d\n", sizeof(outBuf2));
								printf("Buffer2 (%d): %S\n", byteCount, outBuf2);

								// Concatinate to form a full command
								StringCchPrintfW(pcMonitor2, _countof(pcMonitor2), L"monitor3 monitor \"%ls\"", outBuf2);

								printf("Running msnmntr3...\n");
								// Change the string within system() to open a program
								status = _wsystem(pcMonitor2);

								// Check if the system() is failed
								if (status == -1)
								{
									err = _get_errno(&errCode);
									printf("errno = %d\n", err);
								}

								// Notify the driver that we've finished starting msn3
								BOOL bEventStatus = SetEvent(hWaitEvent);
								if (bEventStatus == 0)
									printf("Error at SetEvent\n");
							}
							else
							{
								// Get a failed completed IO request
								if (pOvlStructToWait != NULL)
									printf("Get a failed IOCTL response: %d\n", dwErr);
								else // Get a real error
									printf("GetQueuedCompletionStatus failed: %d\n", dwErr);
							}
						}

					} // End of for loop
				}
			}

		} //  End of if (ERROR_IO_PENDING == dwErr)

		  // if (ERROR_IO_PENDING == dwErr)
		else
			printf("Error at DeviceIoControl: %d\n", dwErr);

	} // if (0 == status)


	CloseHandle(overlappedStruct.hEvent);
	CloseHandle(hWaitEvent);

	return NO_ERROR;
}*/

DWORD
MonitorSendAppPath(
	_In_    HANDLE            monitorDevice)
	/*++

	Routine Description:


	Arguments:

	[in] HANDLE monitorDevice - Monitor Sample device handle.

	Return Value:

	NO_ERROR or DeviceIoControl specific code.

	--*/
{

	DWORD bytesReturned;
	PCWSTR pwsFormattedPath = 0;
	wchar_t pwsPathToSend[300];


	// bypass "C:"
	pwsFormattedPath = globPath + 2;

	// Concatinate with "\Device\HarddiskVolume2"
	StringCchPrintfW(pwsPathToSend, _countof(pwsPathToSend), L"\\Device\\HarddiskVolume2%ls", pwsFormattedPath);

	if (!DeviceIoControl(monitorDevice,
						 MONITOR_IOCTL_APP_PATH,
						 pwsPathToSend,
						 sizeof(pwsPathToSend),
						 NULL,
						 0,
						 &bytesReturned,
						 NULL))
	{
		return GetLastError();
	}


	return NO_ERROR;
}

DWORD
MonitorAppAddFilters(
	_In_    HANDLE         engineHandle,
	_In_    FWP_BYTE_BLOB* applicationPath)
	/*++

	Routine Description:

	Adds the required sublayer, filters and callouts to the Windows
	Filtering Platform (WFP).

	Arguments:

	[in] HANDLE engineHandle - Handle to the base Filtering engine
	[in] FWP_BYTE_BLOB* applicationPath - full path to the application including
	the NULL terminator and size also
	including the NULL the terminator
	[in] CALLOUTS* callouts - The callouts that need to be added.

	Return Value:

	NO_ERROR or a specific result

	--*/
{
	DWORD result = NO_ERROR;
	FWPM_SUBLAYER monitorSubLayer;
	FWPM_FILTER filter;
	FWPM_FILTER_CONDITION filterConditions[2]; // We only need two for this call for flow and stream

	RtlZeroMemory(&monitorSubLayer, sizeof(FWPM_SUBLAYER));

	monitorSubLayer.subLayerKey = MONITOR_SAMPLE_SUBLAYER;
	monitorSubLayer.displayData.name = L"Monitor Sample Sub layer";
	monitorSubLayer.displayData.description = L"Monitor Sample Sub layer";
	monitorSubLayer.flags = 0;
	// We don't really mind what the order of invocation is 
	// because we're monitoring, so whether the sublayer is called first or later is not important
	monitorSubLayer.weight = 0;

	printf("Starting Transaction\n");

	// 0 is begining read/write transaction (access control) to add a sublayer
	result = FwpmTransactionBegin(engineHandle, 0);
	if (NO_ERROR != result)
	{
		goto abort;
	}
	printf("Successfully Started Transaction\n");

	printf("Adding Sublayer\n");

	//---------------------------------------------------------------------------
	// Add sublayer
	result = FwpmSubLayerAdd(engineHandle, &monitorSubLayer, NULL);
	//---------------------------------------------------------------------------
	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Sucessfully added Sublayer\n");

	RtlZeroMemory(&filter, sizeof(FWPM_FILTER));

	// This filtering layer allows for notification of when a TCP connection has been established, 
	// or when non-TCP traffic has been authorized.
	// The differences between flow and stream layer in WFP filters are :
	//		Flow is a whole TCP connection beginning at TCP handshakes (packets belong to one connection)
	//      Stream is all traffic moving in and out your computer, 
	//        it’s always "fresh" and belongs to many connections. (TCP, UDP)
	filter.layerKey = FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4;
	filter.displayData.name = L"Flow established filter.";
	filter.displayData.description = L"Sets up flow for traffic that we are interested in.";
	// FWP_ACTION_CALLOUT_INSPECTION invokes a callout that never returns block or permit.
	filter.action.type = FWP_ACTION_CALLOUT_INSPECTION; // We're only doing inspection. 
	filter.action.calloutKey = MONITOR_SAMPLE_FLOW_ESTABLISHED_CALLOUT_V4;
	filter.filterCondition = filterConditions;
	filter.subLayerKey = monitorSubLayer.subLayerKey;
	filter.weight.type = FWP_EMPTY; // auto-weight.

	filter.numFilterConditions = 2;


	RtlZeroMemory(filterConditions, sizeof(filterConditions));


	//
	// Add the application path to the filter conditions.
	//

	// https://msdn.microsoft.com/en-us/library/windows/hardware/ff549944%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
	filterConditions[0].fieldKey = FWPM_CONDITION_ALE_APP_ID;
	filterConditions[0].matchType = FWP_MATCH_EQUAL;
	// Type of condition value, need to be compatible with matchType. 
	// https://msdn.microsoft.com/en-us/library/windows/desktop/aa364919(v=vs.85).aspx
	filterConditions[0].conditionValue.type = FWP_BYTE_BLOB_TYPE;
	// byteBlob must be defined when conditional value type is FWP_BYTE_BLOB_TYPE
	// byteBlob is the application ID that we got from application path by MonitorAppIdFromPath method
	filterConditions[0].conditionValue.byteBlob = applicationPath;


	//
	// For the purposes of this sample, we will monitor TCP traffic only.
	//
	filterConditions[1].fieldKey = FWPM_CONDITION_IP_PROTOCOL;
	filterConditions[1].matchType = FWP_MATCH_EQUAL;
	filterConditions[1].conditionValue.type = FWP_UINT8;
	filterConditions[1].conditionValue.uint8 = IPPROTO_TCP;


	printf("Adding Flow Established Filter\n");

	result = FwpmFilterAdd(engineHandle,
						   &filter,
						   NULL,
						   NULL);

	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully added Flow Established filter\n");

	RtlZeroMemory(&filter, sizeof(FWPM_FILTER));



	filter.displayData.name = L"Stream Layer Filter";
	filter.displayData.description = L"Monitors TCP traffic.";

	filter.layerKey = FWPM_LAYER_STREAM_V4;
	filter.action.type = FWP_ACTION_CALLOUT_INSPECTION; // We're only doing inspection.
	filter.action.calloutKey = MONITOR_SAMPLE_STREAM_CALLOUT_V4;

	filter.subLayerKey = monitorSubLayer.subLayerKey;
	filter.weight.type = FWP_EMPTY; // auto-weight.

	filter.numFilterConditions = 0;

	printf("Adding Stream Filter\n");

	result = FwpmFilterAdd(engineHandle,
						   &filter,
						   NULL,
						   NULL);
	printf("result from adding stream filter: 0x%x\n", result);

	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully added Stream filter\n");




	// Add filter to monitor child processes
	printf("Adding Filter for child processes.\n");

	// Reuse "filter" and "filterConditions" variable
	RtlZeroMemory(&filter, sizeof(FWPM_FILTER));
	RtlZeroMemory(filterConditions, sizeof(filterConditions));

	filter.layerKey = FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4;
	filter.displayData.name = L"Child Process Flow Established Filter";
	filter.displayData.description = L"Set up flow for child process traffic";
	filter.action.type = FWP_ACTION_CALLOUT_INSPECTION;
	filter.action.calloutKey = CHILD_PROCESS_FLOW_ESTABLISHED_CALLOUT_V4;
	filter.filterCondition = filterConditions;
	filter.subLayerKey = monitorSubLayer.subLayerKey;
	filter.weight.type = FWP_EMPTY;
	filter.numFilterConditions = 1;

	// Add filter conditions
	filterConditions[0].fieldKey = FWPM_CONDITION_IP_PROTOCOL;
	filterConditions[0].matchType = FWP_MATCH_EQUAL;
	filterConditions[0].conditionValue.type = FWP_UINT8;
	filterConditions[0].conditionValue.uint8 = IPPROTO_TCP;

	result = FwpmFilterAdd(
		engineHandle,
		&filter,
		NULL,
		NULL);

	if (NO_ERROR != result)
	{
		goto abort;
	}

	printf("Successfully added filter for child processes.\n");



	printf("Committing Transaction\n");
	result = FwpmTransactionCommit(engineHandle);
	if (NO_ERROR == result)
	{
		printf("Successfully Committed Transaction\n");
	}
	goto cleanup;

abort:
	printf("Aborting Transaction:0x%x\n", result);
	result = FwpmTransactionAbort(engineHandle);
	if (NO_ERROR == result)
	{
		printf("Successfully Aborted Transaction\n");
	}

cleanup:

	return result;
}

DWORD
MonitorAppIDFromPath(
	_In_ PCWSTR fileName,
	_Out_ FWP_BYTE_BLOB** appId)
{
	DWORD result = NO_ERROR;

	result = FwpmGetAppIdFromFileName(fileName, appId);

	return result;
}

DWORD
MonitorAppDoMonitoring(PCWSTR AppPath)
{
	printf("-->MonitorAppDoMonitoring");
	HANDLE            monitorDevice = NULL;
	HANDLE            engineHandle = NULL;
	DWORD             result;
	MONITOR_SETTINGS  monitorSettings;
	FWPM_SESSION     session;
	FWP_BYTE_BLOB*    applicationId = NULL;

	RtlZeroMemory(&monitorSettings, sizeof(MONITOR_SETTINGS));
	RtlZeroMemory(&session, sizeof(FWPM_SESSION));

	session.displayData.name = L"Monitor Sample Session";
	session.displayData.description = L"Monitors traffic at the Stream layer.";

	// Let the Base Filtering Engine cleanup after us.
	session.flags = FWPM_SESSION_FLAG_DYNAMIC;

	printf("Opening Filtering Engine\n");
	result = FwpmEngineOpen(
		NULL,
		RPC_C_AUTHN_WINNT,
		NULL,
		&session,
		&engineHandle
	);

	if (NO_ERROR != result)
	{
		goto cleanup;
	}

	printf("Successfully opened Filtering Engine\n");

	printf("Looking up Application ID from BFE\n");
	result = MonitorAppIDFromPath(AppPath, &applicationId);

	if (NO_ERROR != result)
	{
		goto cleanup;
	}

	printf("Successfully retrieved Application ID\n");

	printf("Opening Monitor Sample Device, create completion port and thread\n");

	result = MonitorAppOpenMonitorDevice(&monitorDevice); // retrieve a handle to the device
	if (NO_ERROR != result)
	{
		goto cleanup;
	}

	printf("Successfully opened Monitor Device\n");

	printf("Successfully created completion port\n");
	printf("Successfully created a thread to wait at completion port\n");

	printf("Adding Filters through the Filtering Engine\n");

	result = MonitorAppAddFilters(engineHandle,
								  applicationId);

	if (NO_ERROR != result)
	{
		goto cleanup;
	}

	printf("Successfully added Filters through the Filtering Engine\n");

	printf("Enabling monitoring through the Monitor Sample Device\n");

	monitorSettings.monitorOperation = monitorTraffic;

	/*result = MonitorAppEnableMonitoring(monitorDevice,
	&monitorSettings);
	// Add function to create and send IO control code for driver notifying
	if (NO_ERROR != result)
	{
	goto cleanup;
	}*/

	printf("Sending app path to the driver...\n");
	result = MonitorSendAppPath(monitorDevice);
	if (NO_ERROR != result)
	{
		printf("Sending app path failed!\n");
		goto cleanup;
	}
	printf("Successfully sent the app path.\n");

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Send IOCTL here
	// Because here is the end of the program
	// we don't need to use asynchronous IOCTL,
	// we can just wait for DeviceIoControl returns
	/*result = MonitorAppSendIoclt(monitorDevice);
	if (NO_ERROR != result)
	{
		goto cleanup;
	}*/



	printf("Events will be traced through WMI. Please press any key to exit and cleanup filters.\n");

#pragma prefast(push)
#pragma prefast(disable:6031, "by design the return value of _getch() is ignored here")
	_getch();
#pragma prefast(pop)

	cleanup:

		   if (NO_ERROR != result)
		   {
			   printf("Monitor.\tError 0x%x occurred during execution\n", result);
		   }

		   if (monitorDevice)
		   {
			   MonitorAppCloseMonitorDevice(monitorDevice);
		   }

		   //
		   // Free the application Id that we retrieved.
		   //
		   if (applicationId)
		   {
			   FwpmFreeMemory((void**)&applicationId);
		   }

		   if (engineHandle)
		   {
			   result = FwpmEngineClose(engineHandle);
			   engineHandle = NULL;
		   }

		   return result;
}

void
MonitorPrintUsage()
{
	wprintf(L"Usage: monitor ( addcallouts | delcallouts | monitor <targetApp.exe> )\n");
}

void StartTraceview(const wchar_t *cmd)
{
	int iStatus;
	errno_t err;
	int errCode;

	// Flush all streams
	_flushall();

	// Start traceview to log traffic
	iStatus = _wsystem(cmd);

	// Check if the _wsystem() is failed
	if (iStatus == -1)
	{
		err = _get_errno(&errCode);
		printf("_wsystem failed = %d\n", err);
	}
}

DWORD
MonitorAppProcessArguments(_In_ int argc, _In_reads_(argc) PCWSTR argv[])
{
	//
	// Copy tracelog.exe + netmon_guids.guid + tracefmt.exe to "c:\"
	// in virtual machine before running this function
	//
	DWORD dStatus;

	if (argc == 2)
	{
		if (_wcsicmp(argv[1], L"addcallouts") == 0)
		{
			return MonitorAppAddCallouts();
		}
		if (_wcsicmp(argv[1], L"delcallouts") == 0)
		{
			dStatus = MonitorAppRemoveCallouts();

			return dStatus;
		}
	}

	if (argc == 3)
	{
		if (_wcsicmp(argv[1], L"monitor") == 0)
		{
			globPath = argv[2];

			// Add callouts
			MonitorAppAddCallouts();

			// Start tracing
			printf("\n\nStarting tracelog...\n\n");
			StartTraceview(L"c:\\tracelog.exe -start netmon2 -guid \"c:\\netmon_guids.guid\" -f \"c:\\netmon_log.etl\" -flag 2");

			// Start to monitor
			dStatus = MonitorAppDoMonitoring(argv[2]);

			// Stop tracing
			printf("\n\nStopping tracelog...\n\n");
			StartTraceview(L"c:\\tracelog.exe -stop netmon2");

			// Generate log file
			printf("\n\nStarting tracefmt...\n\n");
			StartTraceview(L"c:\\tracefmt.exe c:\\netmon_log.etl -p c:\\netmon_pdb -o c:\\netmon_log.txt");

			return dStatus;
		}
	}

	MonitorPrintUsage();
	return ERROR_INVALID_PARAMETER;
}

int __cdecl wmain(_In_ int argc, _In_reads_(argc) PCWSTR argv[])
{
	DWORD result;


	result = MonitorAppProcessArguments(argc, argv); // parse command-line arguments

	return (int)result;
}
